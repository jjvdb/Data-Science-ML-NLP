import numpy as np
import pandas as pd
from sklearn import manifold
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.decomposition import TruncatedSVD
from mpl_toolkits.mplot3d import axes3d, Axes3D
from sklearn.random_projection import sparse_random_matrix


class Visualize:
    """
    This class contains a number of functions for dimensionality reduction and visualization of
    higher-dimensional data sets. It also contains a function to train a K-Means model on the
    input data. The number of clusters that the K-Means model uses can be informed by the graphs
    generated by the plot_2D and plot_3D functions - these can show the number of clusters in the
    data. The dimensionality reduction functions, reduce_dim_pca and reduce_dim_svd, can be used
    to reduce higher-dimensional data sets to 2D or 3D data sets that can then be graphed, for the
    purpose of determining the number of clusters in the data, as outlined above.
    """

    def train_k_means(self, x, n_clusters, init='k-means++', n_init=10, max_iter=300, tolerance=0.0001):
        """
        This function trains a k-means clustering model, using the scikit-learn package.
        Documentation: http://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html

        :param x: np.array([float]) - features to be clustered (float array - 2D, where each row is a data point and
        each column is a feature)
        :param n_clusters: int - the number of clusters to form as well as the number of centroids to generate
        :param init: string - the method for initialization - see above link
        :param n_init: int - the number of time the k-means algorithm will be run with different centroid seeds
        :param max_iter: int - the maximum number of iterations of the k-means algorithm for a single run
        :param tolerance: float - the relative tolerance with regards to inertia to declare convergence
        :return: trained scikit-learn k-means model
        """

        # import the required Python packages
        from sklearn.cluster import KMeans

        # declare k-means model object
        k_means = KMeans(n_clusters, init, n_init, max_iter, tolerance, precompute_distances='auto', verbose=0,
                         random_state=None, copy_x=True, n_jobs=1, algorithm='auto')

        # train model
        k_means.fit(x)

        # return trained k-Means model
        return k_means

    def reduce_dim_pca(self, x, num_components, num_plot_components):
        """
        This function uses PCA to reduce the dimensionality of a 2D matrix, X, and then uses T-SNE to further reduce
        the dimensionality of this matrix, for the purpose of plotting/visualization.
        Documentation (PCA): http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html
        Documentation (T-SNE):http://scikit-learn.org/stable/modules/generated/sklearn.manifold.TSNE.html

        :param x: np.array([float]) - 2D float array - this is the input data
        :param num_components: int - the number of components to which we will reduce the matrix X, using PCA
        :param num_plot_components: int - the number of components to which we shall further reduce the resulting
        PCA-reduced-dimensionality array, using T-SNE, for the purpose of plotting/visualization
        :return: np.array([float]), pd.DataFrame([float])
        """

        # ensure that the number of components for PCA dimensionality reduction is greater than or equal to the number
        # of plot/T-SNE components
        if (num_components >= num_plot_components):

            # ensure that the number of plot/T-SNE components is either 2 or 3
            if ((num_plot_components == 2) or (num_plot_components == 3)):

                # declare PCA object
                pca = PCA(n_components=num_components)

                # get PCA reduced-dimensionality matrix
                principal_components = pca.fit_transform(x)

                # declare T-SNE object
                tsne = manifold.TSNE(n_components=num_plot_components, init='random', random_state=0)

                # get T-SNE reduced-dimensionality matrix
                x_tsne = tsne.fit_transform(principal_components)

                # check if the plot should be 2D or 3D - declare a pandas dataframe of the T-SNE reduced-dimensionality
                #  data accordingly
                if num_plot_components == 2:
                    # declare 2D pandas dataframe
                    plot_data = pd.DataFrame(x_tsne, columns=['Principal Component 1', 'Principal Component 2'])
                else:
                    # declare 3D pandas dataframe
                    plot_data = pd.DataFrame(x_tsne, columns=['Principal Component 1', 'Principal Component 2',
                                                              'Principal Component 3'])
            else:
                # raise error
                raise ValueError("The variable: num_plot_components must be equal to either 2 or 3")
        else:
            # raise error
            raise ValueError("The variable: num_components must be greater than num_plot_components")

        # return both the PCA reduced-dimensionality matrix and the T-SNE reduced-dimensionality matrix
        return principal_components, plot_data

    def reduce_dim_svd(self, x, num_components, num_plot_components):
        """
        This function uses SVD to reduce the dimensionality of a sparse 2D matrix, X, and then uses T-SNE to further
        reduce the dimensionality of this matrix, for the purpose of plotting/visualization.
        This function is used to reduce the dimensionality of sparse matrices, which is useful for applications such as
        Natural Language Processing - for example, the dimensionality reduction of TF-IDF matrices.
        Documentation (SVD): http://scikit-learn.org/stable/modules/generated/sklearn.decomposition.TruncatedSVD.html
        Documentation (T-SNE):http://scikit-learn.org/stable/modules/generated/sklearn.manifold.TSNE.html

        :param x: np.array([float]) - 2D float array - this is the input data
        :param int - num_components: the number of components to which we will reduce the matrix X, using SVD
        :param int - num_plot_components: the number of components to which we shall further reduce the resulting
        SVD-reduced-dimensionality array, using T-SNE, for the purpose of plotting/visualization
        :return: np.array([float]), pd.DataFrame([float])
        """

        # ensure that the number of components for SVD dimensionality reduction is greater than or equal to the number
        #  of plot/T-SNE components
        if (num_components >= num_plot_components):

            # ensure that the number of plot/T-SNE components is either 2 or 3
            if ((num_plot_components == 2) or (num_plot_components == 3)):

                # declare SVD object
                svd = TruncatedSVD(n_components=num_components)

                # get SVD reduced-dimensionality matrix
                principal_components = svd.fit_transform(x)

                # declare T-SNE object
                tsne = manifold.TSNE(n_components=num_plot_components, init='random', random_state=0)

                # get T-SNE reduced-dimensionality matrix
                x_tsne = tsne.fit_transform(principal_components)

                # check if the plot should be 2D or 3D - declare a pandas dataframe of the T-SNE reduced-dimensionality
                #  data accordingly
                if num_plot_components == 2:
                    # declare 2D pandas dataframe
                    plot_data = pd.DataFrame(x_tsne, columns=['Principal Component 1', 'Principal Component 2'])
                else:
                    # declare 3D pandas dataframe
                    plot_data = pd.DataFrame(x_tsne, columns=['Principal Component 1', 'Principal Component 2',
                                                              'Principal Component 3'])
            else:
                # raise error
                raise ValueError("The variable: num_plot_components must be equal to either 2 or 3")
        else:
            # raise error
            raise ValueError("The variable: num_components must be greater than num_plot_components")

        # return both the SVD reduced-dimensionality matrix and the T-SNE reduced-dimensionality matrix
        return principal_components, plot_data

    # function to produce zoomed in scatter plot of pandas data frame data in 2D
    def plot_2d(self, principaldf):
        """
        This function produces an interactive 2D plot of a pandas dataframe.
        Documentation: https://matplotlib.org/index.html

        :param principaldf: pd.DataFrame([float]) - a 2D pandas dataframe with float values, and 2 columns:
        'Principal Component 1' and 'Principal Component 2'.
        :return:
        """

        # declare 2D graph object
        graph2d = plt.axes()

        # set labels of the graph axes
        graph2d.set_xlabel('Principal Component 1')
        graph2d.set_ylabel('Principal Component 2')

        # plot the dataframe values on the 2D graph
        graph2d.scatter(principaldf['Principal Component 1'], principaldf['Principal Component 2'])

        # show the plot
        plt.show()

    # function to produce zoomed in scatter plot of pandas data frame data in 3D
    def plot_3d(self, principaldf):
        """
        This function produces an interactive 3D plot of a pandas dataframe.
        Documentation: https://matplotlib.org/index.html

        :param principaldf: pd.DataFrame([float]) - a 3D pandas dataframe with float values, and 3 columns:
        'Principal Component 1', 'Principal Component 2' and 'Principal Component 3'.
        :return:
        """

        # declare 3D graph object
        graph3d = plt.figure().gca(projection='3d')

        # set labels of the graph axes
        graph3d.set_xlabel('Principal Component 1')
        graph3d.set_ylabel('Principal Component 2')
        graph3d.set_zlabel('Principal Component 3')

        # plot the dataframe values on the 3D graph
        graph3d.scatter(principaldf['Principal Component 1'], principaldf['Principal Component 2'],
                        principaldf['Principal Component 3'])

        # show the plot
        plt.show()


# create new Visualize object to treat and visualize our data set
visualizer = Visualize()

# SVD example
x = sparse_random_matrix(100, 100, density=0.01, random_state=42)

test = visualizer.reduce_dim_svd(x, 20, 3)

visualizer.plot_3d(test[1])

# PCA example
y = np.array([[-1, -1, 1], [-2, -1, 1], [-3, -2, 3], [1, 1, 3], [2, 1, 6], [3, 2, 9]])

test = visualizer.reduce_dim_pca(y, 3, 2)

visualizer.plot_2d(test[1])

# k-means example
km = visualizer.train_k_means(y, 3)

print(km.predict([[1, 1, 0]]))
